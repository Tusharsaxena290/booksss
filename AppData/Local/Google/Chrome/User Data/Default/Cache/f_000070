WEBVTT

00:05.170 --> 00:08.420
したがって､ 前の2つのビデオでは､ クラスについて話してきました｡ 

00:08.560 --> 00:13.550
それはクラスを使用する上で重要なコンストラクターについて話し続けます｡ 

00:13.780 --> 00:16.370
しかし､ それをする前にチャレンジの時間です｡ 

00:16.380 --> 00:19.820
前の2つのビデオの理解に挑戦します｡ 

00:20.080 --> 00:27.650
ここに私があなたにして欲しいものがあります｡ 

00:33.690 --> 00:42.610
私が言ったように､ 挑戦は銀行口座に使われる新しいクラスを作ることだ｡ 

00:42.610 --> 00:47.320
したがって､ クラスのフィールドは､ 残高のアカウント番号になります｡ 

00:47.320 --> 00:53.060
言い換えれば､ 顧客名に電子メールアドレスと電話番号をどのくらいお金がアカウントにあるかということです｡ 

00:53.410 --> 00:56.680
したがって､ 各フィールドにゲッタとセッタを作成する必要があります｡ 

00:57.040 --> 01:00.750
さらに､ このクラスに対して2つの追加メソッドを作成します｡ 

01:00.760 --> 01:08.170
最初の方法は､ 金額で満ちた残高を増分するように､ 顧客顧客が資金を入金できるようにすべきです｡

01:08.410 --> 01:14.600
また､ 顧客が別の方法で資金を引き出せるようにして､ その方法が残高項目から差し引かれるべきである｡

01:14.800 --> 01:20.760
しかし､ 私は彼らが間違っていると思う不十分な資金がある場合､ 撤退が完了することをもう一つは許可します｡

01:21.120 --> 01:24.640
そしてあなたがしたいことは､ メインクラスで様々な挑戦者を作り出すことです｡ 

01:24.700 --> 01:29.640
私はあなたのコードが動作していることを確認するためにインテリジェンスによって当初のクレジットについて話しています｡

01:30.220 --> 01:38.960
また､ 上記の2つのメソッドに印字ラインを追加して､ 入金または出金の量を確認することもできます｡

01:39.160 --> 01:41.180
だから私はビデオを一時停止して試してみました｡ 

01:41.210 --> 01:44.990
私の解決策が戻って来ると言う準備ができたら､ 私たちはそれを乗り越えるでしょう｡ 

01:47.360 --> 01:50.960
あなたが私の解決策をあなたに見せてもらうためにそれを理解してください｡ 

01:50.960 --> 01:54.620
だから､ 私たちがやることはまず､ 新しいクラスを作成することです｡ 

01:54.650 --> 01:56.890
それから､ 前と同じようにパッケージに入れます｡ 

01:57.120 --> 02:01.640
そして､ あなたが知っているように､ 私はこのJavaクラスアカウントを呼び出すつもりです｡ 

02:03.810 --> 02:15.160
あなたは私たちもいくつかのフィールドが必要であることを知っているので､ Leboeufというアカウントが必要です｡

02:15.440 --> 02:17.060
あなたが望むなら､ あなたは数字を使うことができます｡ 

02:17.320 --> 02:18.570
また､ バランスも必要です｡ 

02:18.590 --> 02:26.700
バランスを取るためにトップを使用するつもりですが､

02:33.060 --> 02:42.290
キャップバランスとお客様の夜間メールアドレスを入れて､ トリガーを使用する場合は､ 今夜はOKです｡

02:45.240 --> 02:53.460
実際には､ ｡

02:53.840 --> 03:01.870
クラス時間がカウントと呼ばれるので､ 私たちはすでにWupを使用しているので､ Adaを使うことができます｡

03:01.910 --> 03:07.300
私たちはそれを示すことができます｡

03:07.620 --> 03:14.600
私たちはそれがアカウントに基づいていることを知っていることを知っています｡ 現行のクラスのためのものだから､ アカウントの単語を2度入れる必要はありません｡

03:14.600 --> 03:20.540
私が次に言ったように私たちは私たちを取得し､ あなたが定期的に行うことはとても一般的なことなので､

03:20.540 --> 03:25.320
今すぐ知人を使ってゲッターとセッターを作るテクニックをあなたに示すつもりだと言っています｡

03:25.310 --> 03:30.300
それについて話す方法はありますが､ それはカードに入ることですが､ Gennaをクリックすると､ 自分のコンピュータコマンドを言うことができ､

03:30.310 --> 03:33.390
同じことができます｡

03:33.660 --> 03:35.050
私は生成することができます｡ 

03:35.330 --> 03:43.260
そしてあなたはそれをクリックすることができますが､ すべてのセットアップを取得し､ どちらのフィールドを選択する必要がある両方をクリックするように設定されました｡

03:43.400 --> 03:50.410
だから私は1つ以上を選択することができ､ それがプライベートフィールドであることとコースフィールドであることを示すかどうかを見ることができます｡

03:50.420 --> 03:54.910
OKをクリックすると､ インテリジェントはすべてのコードを作成します｡ 

03:54.920 --> 03:56.180
それはどれくらいうれしいですか｡ 

03:56.210 --> 03:59.650
多くの話題がたくさんあるので､ それはかなりクールな方法です｡ 

03:59.650 --> 04:02.320
非常に迅速に私たちを得ることができ､ 作成しました｡ 

04:02.400 --> 04:03.580
だから私は実際にそれをチェックする｡ 

04:03.580 --> 04:07.220
Liathの他のタイプのコード生成については､ これを参照します｡ 

04:07.400 --> 04:13.130
だから私が立ち上がって､

04:13.730 --> 04:23.720
創造されたとき次に､ 私たちは使徒と撤退という2つの方法を作り､ 公的な預金である預金の一つの問題を空法とすることから始めることができます｡

04:24.140 --> 04:27.070
そして､

04:30.920 --> 04:34.160
私たちは預金金額のパラメータを過ぎてから､ 私たちがやりたくない残高に追加します｡

04:34.160 --> 04:39.530
残高は地図を置き換える予定の預金金額と同じです｡ 残高に対して現在設定されている金額は､

04:39.530 --> 04:43.240
プラス均等演算子を使用して残高に加算されます｡

04:43.670 --> 04:45.920
だからそのバランスに追加されます｡ 

04:45.920 --> 04:52.330
わかりやすく説明するため､ これを使って､ これが更新中の燃料であることを確認することができます｡ 

04:52.340 --> 05:05.080
それは､ 撤退1共和国の無効な撤退とマットの上に落ちるための積極的な機能です｡

05:05.480 --> 05:11.110
私達はいくつかの引き出しを取り下げるときにこの方法を過ぎました｡ 

05:12.710 --> 05:18.550
だから私たちが今できることは､ 撤退を購入するのに十分な資金があるかどうかを調べることです｡ 

05:18.560 --> 05:29.150
したがって､ これを行う最も簡単な方法は､ 銀行口座の現在の残高と私たちが引き出したい金額のバランスを取ることです｡

05:29.630 --> 05:35.810
の残高が0以下であれば､ 十分なお金がないことを意味します｡ 

05:35.990 --> 05:49.710
だから私たちは､ この元のビデオが記録された後､ ビデオのこのビットでは問題ではなく､ 危機ではなく､

05:53.150 --> 05:57.560
バランスのとれた撤退だけを置くメッセージを出すつもりです｡

05:57.560 --> 06:01.500
それは､ 撤退方法にスロットのバグがあることを知らせることです｡ 

06:01.640 --> 06:02.660
彼らはそれを見ることができます｡ 

06:02.790 --> 06:07.750
私は実際にゼロよりも小さいか等しいテイチの撤退金額を持っています｡ 

06:08.090 --> 06:16.220
実際には､ 引き出し金額がゼロ未満のバランスでなければならず､ 画面上に正しいカードと同等のものが表示されます｡

06:16.640 --> 06:20.150
その理由は､ 次のビデオで詳しく説明されています｡ 

06:20.250 --> 06:22.280
実際にコードを変更して変更します｡ 

06:22.280 --> 06:26.910
しかし､ 私は今あなたが探していることと､ 何が起こっているのだろうかと思っている場合に備えて､ 今ここに持ってきています｡ 

06:27.050 --> 06:33.830
私たちがパンに入るかどうかを確認したいからです｡

06:33.830 --> 06:38.510
言い換えれば､ 私たちが未成年者に入った場合､ 銀行口座に10ドルを払い､

06:39.230 --> 06:42.710
10ドルを引き出して残高をゼロにすることは可能です｡

06:42.950 --> 06:44.080
だからそれはかなり可能です｡ 

06:44.120 --> 06:46.930
そして､ あなたは銀行口座を閉鎖するたびにそれを行います｡ 

06:47.180 --> 06:59.240
実際には残高がゼロ未満の場合に引き出しを処理できない場合にエラーを表示することができる時代を実際に示しているからです｡

06:59.270 --> 07:03.580
正しいものではないが､ 次のビデオで完全に説明することはできません｡ 

07:03.740 --> 07:06.120
私はちょうどあなたの注意をここに持ってきています｡ 

07:09.120 --> 07:10.070
そうではありません｡ 

07:10.440 --> 07:17.750
この場合に起こったことは､ 役割と同等のバランスを取るように処理できることです｡

07:17.760 --> 07:36.260
したがって､ 残高から引き出し金額を差し引くつもりですし､ ペレットは残金残高の撤回を行う予定です｡

07:38.250 --> 07:39.960
それはそれがメトロです｡ 

07:40.050 --> 07:41.070
それでおしまい｡ 

07:41.130 --> 08:02.200
そして､ ここで私たちはちょうどその金額を入れないかもしれませんが､ 残高がバランスをとっていて､ 一貫性があるのは本当にデソクを入れておかなければなりません｡

08:02.650 --> 08:10.230
パラメータの引き渡しが同じ名前ではないので問題はありません｡

08:10.360 --> 08:16.810
しかし､ 私があなたに言いたいことは､ あなたの命名とコードとの一貫性を保つことです｡ 

08:16.840 --> 08:18.360
それで､ あなたがそれをやろうとしていることを知っているのは良いことです｡ 

08:18.350 --> 08:22.700
時には､ 実際にはいつもそれを行う必要があります｡ この場合､

08:22.760 --> 08:26.360
クラスの仕方を知っているフィールドを参照するときにこの始まりを使用します｡

08:27.430 --> 08:34.840
それでは､ 私たちが今すべてを書いた私たちのキャンプクラスのための機能だと私たちは働いている機能を入金し､ 取り消すつもりです｡

08:34.840 --> 08:40.320
だから今私たちがやるべきことは､ 私たちのメインクラスに戻るということです｡ 

08:40.330 --> 08:44.190
私たちはそこに行って､ 私たちは新しいものを作り出すつもりです｡ 

08:44.240 --> 09:01.400
NicolletアカウントのPOBアカウントは新しいアカウントを最初にテストするつもりですBobsyは100を引き出すことはできません｡

09:02.310 --> 09:03.970
それを実行して何が起こるか見てみましょう｡ 

09:11.790 --> 09:14.840
0｡  0あなた自身の価格で利用可能です｡ 

09:14.850 --> 09:16.890
それはやっているべきことをすることだけでいいです｡ 

09:20.040 --> 09:20.640
だからそれは良いです｡ 

09:20.640 --> 09:30.770
次に､ ポップ口座預金50ドルを払い､ 同じ引き出しをしようとしています｡

09:30.930 --> 09:34.290
それはまだファイルされている必要があり､ それは私たちに異なるバランスを与える必要があります｡ 

09:34.540 --> 09:41.640
あなたの価格で利用可能な50 0を実行しようとしましょう｡

09:41.640 --> 09:42.600
それは良い｡ 

09:43.020 --> 09:51.970
だから､ ボブの口座に50ドルのもう一つの預金を教えて､ 2パブはボブの口座を撤回し､ 100ドルで撤退します｡

09:51.970 --> 09:57.910
これで100ドルが得られるので､ $

09:57.910 --> 10:01.350
1の残高があるはずです｡

10:01.490 --> 10:12.220
それは$ 51を預金するMajdiの預金101を撤回することを実行している｡  00 1｡

10:12.220 --> 10:12.220
0｡ 

10:12.880 --> 10:14.070
だからこそそれが挑戦です｡ 

10:14.070 --> 10:21.100
うまくいけば､ あなたはそれらのラインに沿って何かを持っているし､ あなたは本当に素晴らしい自分のクラスを初めて作成しました｡

10:21.100 --> 10:25.180
もちろん､

10:25.180 --> 10:31.210
実際には他の値を設定したのではなく､ 他の値を使用したい場合は､ Bobのアカウントが設定され､

10:32.870 --> 10:45.840
引数として2 3 4 4が設定されているようなものです酒は分かりませんが､ 今はBobのアカウントが設定されているので､ Bobのアカウントが顧客を設定していないことがわかります｡

10:46.260 --> 11:02.170
BOB BROWN Bobsyは､ パワフルなドットコムで顧客の電子メールアドレスまたは電子メールを座らせることはできず､ ABAのボブのアカウントは0 8 7 1 2 3

11:02.270 --> 11:09.280
4 5 6 7に設定されています｡

11:09.620 --> 11:16.080
だから最初にフィールド値を最初に設定するすべての変数を設定する必要がある場合は､ そこで多くのことを話すことができます｡

11:16.370 --> 11:22.320
あなたが10または20または30を持っていたらあなたが出会ったなら､ 実際にそれを行うにはかなりのコードになる可能性があります｡ 

11:22.550 --> 11:27.050
しかし､ クラスを使用して初めてオブジェクトを作成しているときに､ コンストラクタを使用しているときに､

11:27.350 --> 11:29.210
これを行う別の方法があります｡

11:29.630 --> 11:34.490
したがって､

11:34.610 --> 11:41.550
コンストラクタを使用してできることは､ これらのコマンドをすべて基本的に実行して､ コンストラクタを使用して1つのヒープで実行する他の初期化のフィールドの初期値を設定することです｡

11:41.690 --> 11:47.260
だから私たちがこれを置き換えることができるかどうかを見てみましょう｡ 私はJavaとコンストラクタを追加することはできません｡ 

11:47.540 --> 11:52.850
まず最初に､ コンストラクタが実際にjavacによって自動的に作成されることがわかります｡ 

11:53.180 --> 11:57.270
そしてあなたが実際にあなたに括弧内のクラスの名前を教えたとき｡ 

11:57.500 --> 11:59.250
これは実際にコンストラクタを呼び出しています｡ 

11:59.250 --> 12:08.030
これは実際にクラスを作成する特別なメソッドを呼び出していますが､ その目的はクラスの強制からオブジェクトを物理的に作成することです｡

12:08.090 --> 12:14.150
したがって､ あなたがアカウントクラスに入ると､ 私たちは独自のコンストラクタを作成します｡ 

12:14.450 --> 12:20.530
だから私たちがやろうとしているのは2人の公衆ですが､ 実際の夜にはクラスの正確な名前をつけることです｡

12:20.530 --> 12:25.400
ブラトゥナックのトップコンストラクターは特別なものです｡ 

12:25.400 --> 12:31.630
それはアクセス修飾子とクラスの名前だけを持ち､ 名前のようにパラメータの数を持っています｡

12:31.970 --> 12:37.520
それで私がやることは､ これが動作していることを示すことです｡ コンストラクタを作成したということは､

12:39.520 --> 12:42.060
他に何もないコンストラクタに入れようとしていることです｡

12:42.110 --> 12:43.930
これは通常自動的に作成されます｡ 

12:43.930 --> 12:46.190
しかし､ 私がやったことは､ 物理的にタイプしたことです｡ 

12:46.190 --> 12:49.000
ですから､ このJavaをコンパイルするときには､ そのことが見えます｡ 

12:49.040 --> 12:51.090
私は自分のコンストラクタをどのように作成しているのが好きです｡ 

12:51.260 --> 12:52.720
私は試してみると私はそれを持ってきました｡ 

12:53.060 --> 13:00.380
だから私たちがこれを実行するならば､ 私たちがトップで言うべきことは､ あなたが今追加したメッセージが今ここでトップに見ることができるということです｡

13:00.430 --> 13:02.020
解体コードの場合｡ 

13:02.120 --> 13:11.420
だから私たちが話をしたときに､ 実際にこの目的のコンストラクタを自動的に実行したパラメータを括弧で囲んで説明します｡

13:11.420 --> 13:15.530
つまり､

13:15.530 --> 13:21.010
コンストラクタの目的は､ 作成しているオブジェクトを本質的に初期化し､ オブジェクトが作成されているときに何をしたいのかを実行することです｡

13:21.020 --> 13:25.840
だから私は一度だけコードを作成するときに､ オブジェクトを作成する必要があります｡ 

13:26.060 --> 13:31.490
では､ 別のコンストラクタを追加し､ いくつかのパラメータを設定して､

13:31.490 --> 13:33.680
セッタを使う代わりにコンストラクタでこれらの値を設定しましょう｡

13:33.920 --> 13:41.320
このようにするには､ ここに戻って､ コンストラクタのようにオーバーロードすることができるため､ 別のコンストラクタを作成することができます｡

13:41.330 --> 13:46.430
私たちは､

13:46.430 --> 13:52.580
変更しようとしているパラメータの数を変更し､ 他のパラメータは公的なアカウントで行うつもりであれば､ 複数のコンストラクタを持つことができます｡

13:53.250 --> 13:59.570
今私たちがやることは､

14:02.100 --> 14:10.290
ストリングナボスの二重バランスの強さの保護を置く数字を初期化することです｡ 私たちが何が起こっているかを考えるのを助けようとする知性だけではありません｡

14:10.320 --> 14:12.430
コンストラクタを作成していることを確認してください｡ 

14:12.510 --> 14:16.490
どのコンストラクタをこのコンストラクタのパラメータとして含めるかを指定します｡ 

14:16.630 --> 14:31.530
これは非常に便利なので､ すべてを指定して顧客の電子メールアドレスと文字列を次の下位顧客の電話番号に文字列で入力してください｡

14:31.550 --> 14:41.930
この番号を設定する前にこの番号を設定しました｡ この顧客名と顧客名の電子メールアドレスが顧客の電子メールアドレスと一致し､

14:42.410 --> 14:50.720
顧客の電話番号をデポジットする残高を持つ停止残高をECO番号に設定しています｡

14:50.720 --> 14:57.280
顧客は最終的にコンストラクタに食べ物の腹をセットしているからです｡ 

14:57.590 --> 15:03.050
しかし､ 私たちが行う必要のないことは､ コンストラクタを呼び出すことです｡ オブジェクトを作成するときに､ コンストラクタが1 2 3

15:03.050 --> 15:10.870
4 5 0のようなパラメータを渡すのではなく､ そのコンストラクタを呼び出すようにします｡ 00｡ 

15:11.170 --> 15:18.710
BOB BROWN私の今の目標は公衆通信と0 8 7 1 2 3

15:21.710 --> 15:27.080
4 5 6 7です｡

15:27.250 --> 15:31.330
私たちはブラケットを閉めて､ 私の一日を修正します｡ 

15:31.380 --> 15:35.500
私はそれが法だと言ったような白い政治を忘れてしまった｡ 

15:35.500 --> 15:41.280
私たちが行ったことは､ 今や冗長であるという考えコンストラクタが私たちのために行っているので､ これを行う必要はありません｡

15:41.360 --> 15:45.430
それが機能していることを確認するためにここに戻って､

15:48.950 --> 15:57.720
Try on thisというパラメータを持つ現在のコンストラクタを置くことができます｡

16:00.900 --> 16:03.870
パラメータを指定したキャンプコンストラクタです｡ 

16:03.890 --> 16:04.430
あなたはできません｡ 

16:04.430 --> 16:11.390
そして､

16:11.390 --> 16:34.020
パラメータと値はコンストラクタで自動的に更新され､ 私たちはできることをいくつか外に出すことで確認できますPopsieは番号を取得できませんPLXを実行するだけのデバイスです｡ 0｡

16:34.020 --> 16:35.220
00それで､ 私たちは実際にコンストラクタを守っています｡

16:35.460 --> 16:40.040
今私は､ コンストラクタがオーバーロードされる可能性があることを前に述べました｡ 

16:40.350 --> 16:41.390
しかし､ もう一つは｡ 

16:41.760 --> 16:48.730
したがって､ 私たちができることは､ 別のコンストラクタから1つのコンストラクタを呼び出すことができることです｡ 

16:48.900 --> 16:55.460
これはちょっと混乱しますが､ 空のコンストラクタが呼び出された場合は､ そうすることが考えられます｡

16:55.470 --> 16:58.410
言い換えれば､ 言い換えれば､ パラメータを持たないものです｡ 

16:58.410 --> 17:02.620
おそらく､ いくつかのデフォルト値を持つオブジェクトを作成したいと考えています｡ 

17:02.760 --> 17:03.810
だから私はそれが何を意味するのですか？

17:03.810 --> 17:09.390
したがって､ このシナリオでは､

17:10.050 --> 17:17.350
空のコンストラクタが呼び出された場合にはOKを返すことができます｡ これらのパラメータをすべてコンストラクタとして実際に呼び出す場合､ 5つのフィールドに対してデフォルト値を発行します｡

17:17.430 --> 17:25.390
これを行うには､ これが私たちが前提を渡すかたちで話す方法の特別なケースだと思ったので､ 5

17:25.390 --> 17:36.180
6 7 8

17:38.940 --> 17:45.820
9とそのバランスを50に設定しました｡

17:47.160 --> 17:51.430
だから私たちがこれで何をしているのかは､ あなたが他のどこにも見られない特別な使い方です｡ 

17:51.540 --> 17:55.080
これは､ コンストラクタ内で別のコンストラクタを呼び出しています｡ 

17:55.080 --> 18:00.450
だから私たちがここで言うことは､

18:00.450 --> 18:06.170
あなたがこのクラスからオブジェクトを作成して作成し､ 私にこのオブジェクトを作成するときに使用するパラメータであるパラメータを与えていないかどうかを調べることです｡

18:06.210 --> 18:08.330
これはオプションです｡ あなたがしなければならないことではありません｡ 

18:08.520 --> 18:13.230
しかし､

18:13.230 --> 18:18.910
クラスがすべてのフィールドセットで作成されていることを確認したい場合や､ デフォルトのコンストラクターを発行してそれを行うことができるようにしたいときに､ 状況を行うことができます｡

18:19.020 --> 18:24.420
もう一つ注意すべき点は､ これを使って別のコンストラクタを呼び出すことです｡

18:24.420 --> 18:28.050
実行する最初の行であることを確認する必要があります｡

18:28.050 --> 18:34.080
つまり､ コンストラクタの最初の行があるように､ システムにペーストすることができませんでした｡

18:34.270 --> 18:39.420
なぜなら､ 実際にコルタがコンストラクタ本体の最初の文でなければならないと言うことができるからです｡

18:39.460 --> 18:41.670
これは私たちが話しているコンストラクタです｡ 

18:41.670 --> 18:45.110
それは､ その背後にあると呼ばれる最初の行でなければなりません｡ 

18:45.150 --> 18:47.660
だから私のクラスに戻り､ もう一度実行してください｡ 

18:49.660 --> 18:51.130
それはまったく同じことです｡ 

18:51.120 --> 18:53.440
あなたは言うことができるが､ 今それを変更しよう｡ 

18:53.990 --> 18:58.060
これはアカウントに設定され､ 残りの部分をコメントアウトして再び空にします｡ 

19:00.490 --> 19:04.000
それで､ 次のラインも正しいです｡ 

19:04.000 --> 19:15.990
ここで空のコンストラクタを使って実行すると､ 実際にデフォルトのコンストラクタから適切な値を取得し､ countコンストラクタで何が起きたのかを知ることができます｡ そして､

19:15.990 --> 19:24.680
空のコンストラクタが呼び出されました｡ その理由と､ あなたがアカウントデストラクタコードの最初の行まで会計士の仕事に戻って来るならば､

19:24.680 --> 19:30.870
あなたがその順序でそれを言う理由は理にかなっています｡

19:30.900 --> 19:35.330
もう一方のコンストラクターは､ それが完了した後で､ 実際にこれを印刷しました｡ 

19:35.640 --> 19:41.780
だから､ 何が起こったのかは､ 空のコンストラクタが呼び出されたデフォルトのコンストラクタか､ 最初の行のコードです｡

19:41.780 --> 19:44.670
もう1人はそのメッセージを印刷しました｡ 

19:45.000 --> 19:49.380
あなたがそれを見ていて､ よく考えているのであれば､ なぜパラメータコードを持つ契約が最初ですか？

19:49.410 --> 19:50.880
実際に最初に呼ばれたわけではありません｡ 

19:50.880 --> 19:54.090
それはちょうど我々のメッセージでそのように表示されます｡ 

19:54.150 --> 19:58.570
そう､ はい､ あなたは5 6 7 8 9と2と言うことができます｡  5が実際に渡されました｡ 

19:58.620 --> 20:03.960
つまり､ デフォルトのコンストラクタが動作していることは明らかです｡ ここでビデオを一時停止し､

20:03.960 --> 20:07.700
次のビデオに戻ってコンストラクタの説明を終えます｡
